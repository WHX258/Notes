# 继承

**继承是面向对象三大特性之一**

类有父类（基类）和子类（派生类），子类继承父类的特性，并发展自己的特性

## 基本语法

**==class 子类 : 继承方式 父类==**

继承方式有：
* 公共（public）
* 保护（protected）
* 私有（private）

比如：
```C++
//公共页面
class BasePage {
public:
	void header()
	{
		cout << "首页、公开课、登录、注册...（公共头部）" << endl;
	}

	void footer()
	{
		cout << "帮助中心、交流合作、站内地图...(公共底部)" << endl;
	}
	void left()
	{
		cout << "Java,Python,C++...(公共分类列表)" << endl;
	}

};

//Java页面
class Java : public BasePage
{
public:
	void content()
	{
		cout << "JAVA学科视频" << endl;
	}
};

```

## 继承方式

![alt text](继承方式.png)

public继承：
|父类                |子类      |
|--                  |--        |
|公共（public）      |public    |
|保护（protected）   |protected |
|私有（private）     |不可访问  |

protected继承：
|父类                |子类      |
|--                  |--        |
|公共（public）      |protected |
|保护（protected）   |protected |
|私有（private）     |不可访问  |

private继承：
|父类                |子类      |
|--                  |--        |
|公共（public）      |private   |
|保护（protected）   |private   |
|私有（private）     |不可访问  |

**父类的所有内容都会被子类所继承，这在内存上有体现，只是访问不到private的罢了。**

## 父类 / 子类的构造 / 析构顺序
现有的父亲后有的孩子，有点像栈？
**父类构造 -> 子类构造 -> 子类析构 -> 父类析构**

## 父类子类有同名成员时
子类访问子类同名变量/函数：直接访问
子类访问父类同名变量/函数：**加作用域**
**对静态变量/函数：** 处理方式一样，只不过有两种访问的方式（通过对象s.m_A 和 通过类名Son::Base::m_A）

**示例：**
```C++
class Base {
public:
	Base()
	{
		m_A = 100;
	}
	void func()
	{
		cout << "Base - func()调用" << endl;
	}
	void func(int a)
	{
		cout << "Base - func(int a)调用" << endl;
	}
public:
	int m_A;
};


class Son : public Base {
public:
	Son()
	{
		m_A = 200;
	}
	void func()
	{
		cout << "Son - func()调用" << endl;
	}
public:
	int m_A;
};

void test01()
{
	Son s;
	cout << "Son下的m_A = " << s.m_A << endl;
	// 加作用域访问父类的
	cout << "Base下的m_A = " << s.Base::m_A << endl;
	s.func();
	// 加作用域访问父类的
	s.Base::func();
	s.Base::func(10);

}
int main() {
	test01();
}
```

**静态示例：**

```C++
class Base {
public:
	static void func()
	{
		cout << "Base - static void func()" << endl;
	}
	static void func(int a)
	{
		cout << "Base - static void func(int a)" << endl;
	}

	static int m_A;
};

int Base::m_A = 100;

class Son : public Base {
public:
	static void func()
	{
		cout << "Son - static void func()" << endl;
	}
	static int m_A;
};

int Son::m_A = 200;

//同名成员属性
void test01()
{
	//通过对象访问
	cout << "通过对象访问： " << endl;
	Son s;
	cout << "Son  下 m_A = " << s.m_A << endl;
	cout << "Base 下 m_A = " << s.Base::m_A << endl;

	//通过类名访问
	cout << "通过类名访问： " << endl;
	cout << "Son  下 m_A = " << Son::m_A << endl;
	cout << "Base 下 m_A = " << Son::Base::m_A << endl;
}

//同名成员函数
void test02()
{
	//通过对象访问
	cout << "通过对象访问： " << endl;
	Son s;
	s.func();
	s.Base::func();

	cout << "通过类名访问： " << endl;
	Son::func();
	Son::Base::func();
	//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问
	Son::Base::func(100);
}
int main() {

	//test01();
	test02();

	system("pause");

	return 0;
}
```