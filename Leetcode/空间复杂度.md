# 空间复杂度

## 1. 定义

对一个算法在**运行过程中占用内存**空间大小的量度，记做$S(n)=O(f(n))$，依然使用大O表示。这只是一个大体的评估，还有很多其他因素会影响程序真正内存使用大小。

* $O(1)$: 随着$n$的变化，所需开辟的内存空间并不会随着$n$的变化而变化。例如：
``` C++
int j = 0;
for (int i = 0; i < n; i++) {
    j++;
}
```

* $O(n)$: 消耗空间和输入参数$n$保持线性增长。例如：
```C++
int* a = new int[n];
```

## 2. 递归的空间复杂度
**递归算法的空间复杂度 = 每次递归的空间复杂度 * 递归深度**
e.g.: 二分查找
```C++
int binary_search( int arr[], int l, int r, int x) {
    if (r >= l) {
        int mid = l + (r - l) / 2;
        if (arr[mid] == x)
            return mid;
        if (arr[mid] > x)
            return binary_search(arr, l, mid - 1, x);
        return binary_search(arr, mid + 1, r, x);
    }
    return -1;
}
```
* 递归深度的计算：
假设在一个有序数组中查找目标值，数组长度为 n = 16：
第 1 步：问题规模是 16
第 2 步：只需在左半边或右半边查找（规模变为 8）
第 3 步：规模为 4
第 4 步：规模为 2
第 5 步：规模为 1，查找结束
$n → n/2 → n/4 → ... → 1$
算1乘多少次2得到n，即 $\log₂(n)$
<br/>
* 每次递归的空间复杂度: 每次都调用的是arr (C++中传入数组是数组首元素地址)，不变，所以是$O(1)$
* $空间复杂度 = O(1) \times O\log(n) = O\log(n)$
